{"meta":{"title":"Hogwarts","subtitle":"Gryffindor","description":"Magic","author":"Sirius Black","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-06-06T12:54:44.000Z","updated":"2018-06-07T01:45:06.658Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"heheda"},{"title":"tags","date":"2018-06-06T12:41:24.000Z","updated":"2018-06-06T12:41:24.410Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Netty中的ByteBuf","slug":"netty_bytebuf","date":"2018-02-13T02:20:30.000Z","updated":"2018-06-06T12:32:02.704Z","comments":true,"path":"2018/02/13/netty_bytebuf/","link":"","permalink":"http://yoursite.com/2018/02/13/netty_bytebuf/","excerpt":"","text":"类结构简介 从图中可以看出，ByteBuf最重要的子类是AbstractByteBuf，其他四个除了EmptyByteBuf是实现了空ByteBuf外都是直接或者间接的引用AbstractByteBuf的。AbstractByteBuf有两个子类：AbstractDerivedByteBuf和AbstractReferenceCountedByteBuf，AbstractDerivedByteBuf的实现类也只是一层代理，并不会去实际操作数据；我们这里也主要讲下AbstractReferenceCountedByteBuf类及其实现类。 AbstractReferenceCountedByteBuf的实现类主要可以用两个维度去分类：Direct or Heap、Pooled or UnPooled（是否用了对象池）。 Direct or Heap，内存用的是堆内存还是直接内存HeapByteBuf，目前有两个buffer类是直接使用堆内存实现的，看名字就可以轻易找出来，就是UnpooledHeapByteBuf和PooledUnsafeDirectBytebuf。他们的特征是底层维护了一个字节数组(byte[])用来存储所需要的数据，所以内存是直接由JVM堆内存分配的。 DirectByteBuf，目前有三个buffer类是使用直接内存实现的，UnpooledUnsafeDirectByteBuf、UnpooledDirectByteBuf、PooledUnsafeDirectByteBuf以及PooledDirectByteBuf。这几个类是维护了一个DirectByteBuffer对象，由DirectByteBuffer对象申请对外内存来储存数据。 CompositeByteBuf，并不一定使用哪种内存方式，他只是将多个ByteBuf合并成一个进行操作，且无需拷贝。 Pooled or UnPooled，是否使用了对象池技术UnpooledByteBuf，没有使用对象池技术的ByteBuf PooledBytebuf，使用了对象池技术的ByteBuf ByteBuf接口介绍ByteBuf虽然定义的是一个抽象类，其实更像一个接口，没有实现任何方法。该类实现了ReferenceCounted接口，这个接口暂时还没去了解，看名字应该是引用计数相关，方便buffer使用完后释放。 为什么不直接用JDK提供的ByteBuffer进行数据传输呢？JKD自带的ByteBuffer有诸多局限性，比如不能自动扩展，读写共用一个指针等。BufferBuff内部维护了读写两个指针，可以更清晰的进行数据读写且不需要调用flip()方法进入读就绪。盗用一下netty文档上的示意图： 123456+-------------------+------------------+------------------+| discardable bytes | readable bytes | writable bytes || | (CONTENT) | |+-------------------+------------------+------------------+| | | |0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity ByteBuf用readerIndex和writerIndex两个指针将整个数据区域分成了三块，初始状态下readerIndex和writerIndex都是0。写入数据的时候，readable bytes这块会增加，相应的writable bytes这块会减小（不扩展的情况下）；读取数据的时候，readable bytes会减小，discardable bytes这块会增大；discardable 区理论上是已经没用的可丢弃的数据，可以通过discardReadBytes()方法把readable和writable区往前移。 如果一个操作让上面的不等式不成立此操作就会抛IndexOutOfBoundsException，write操作除外，write时会先检查writable bytes区大小，即使不够也会扩容，除非maxCapacity - writerIndex的值小于该操作写入的长度。操作之前可以通过ByteBuf接口提供的方法判断是否可写可读： 123456while(buf.isWritableBytes() &gt;= 4) &#123; buf.writeInt(1);&#125;while(buf.isReadable()) &#123; System.out.print(buf.readByte());&#125;","categories":[{"name":"netty","slug":"netty","permalink":"http://yoursite.com/categories/netty/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"netty","slug":"netty","permalink":"http://yoursite.com/tags/netty/"}]},{"title":"bitwise_operation_in_java","slug":"bitwise_operation_in_java","date":"2018-02-12T02:20:30.000Z","updated":"2018-06-06T12:32:02.703Z","comments":true,"path":"2018/02/12/bitwise_operation_in_java/","link":"","permalink":"http://yoursite.com/2018/02/12/bitwise_operation_in_java/","excerpt":"","text":"Java中的位运算jdk源码中很多操作都涉及到位运算（如HashMap中取2^30用1 &lt;&lt; 30，ByteBuffer中将两个byte组成short用(short)((b1 &lt;&lt; 8) | (b0 &amp; 0xff))），因为计算机底层数据都是以二进制形式存储的，所有的运算最终其实都是转换成二进制进行位运算，所以直接位运算具有与生俱来的高效性。 位运算符号 &amp; 按位与运算 A &amp; B，每位进行比较，相同位都是1则此位结果为1，否则结果为0 | 按位或运算 A | B，每位进行比较，相同位都是0则此位结果为0，否则结果为1 ~ 按位非运算 ~A，单元运算，每位取反 ^ 异或运算 A ^ B，每位进行比较，相同位值相同则此位结果为0，否则结果为1。也称不进位加法 &lt;&lt; 左移运算 A &lt;&lt; n，把所有位向左移动n位，右边空出来的n位用0填充 >> 右移运算 A &gt;&gt; n，把所有位向右移动n位，左边空出来的n位用原数的符号位填充 >>> 无符号右移运算 A &gt;&gt;&gt; n，把所有位向右移动n位，左边空出来的n位用0填充 主要讲讲右移运算与无符号右移运算，右移运算是将所有位位移后左边用符号位补齐，所以运算完后符号位不变。而无符号右移运算运算完后都会用0补齐，所以运算完后肯定是正数。 举个例子，对于十进制的数DEC(-101) = BIN(11111111 11111111 11111111 10011011) 对其进行右移运算的结果是： BIN(11111111 11111111 11111111 10011011) &gt;&gt; 2 = BIN(11111111 11111111 11111111 11100110) 1int a = -101 &gt;&gt; 2; // 计算结果为-26 对其进行无符号右移运算的结果是： BIN(11111111 11111111 11111111 10011011) &gt;&gt; 2 = BIN(00111111 11111111 11111111 11100110) 1int a = -101 &gt;&gt;&gt; 2; // 计算结果为1073741798 基本数据类型间的转换 在这里我们只关心四种正数类型的转换，byte、short、int、long byte、short、int、long所能表示的范围是逐步扩大，前面能表示的范围是后面的一个子集。 所以将范围小的数据类型转换成范围大的数据类型，在Java中可以隐式转换且能保证值不变。如以下表达式： 12byte b = -11;int i = b; 因为要保证值不变，所以从byte转成long的时候多出的24位用原始byte值的符号位填充： BIN(11110101) -&gt; BIN(11111111 11111111 11111111 11110101) 将大范围的数据类型转成小范围的数据类型就有问题了，位数不够用！Java语言中对这种类型的转换也需要显示进行（强制类型转换），对于这种转换，做法很暴力，直接把多出来的高位抹去。 12int i = 10086;byte b = (byte) i; DEC(10086) = BIN(‭00000000 00000000 00100111 01100110‬) -&gt; BIN(01100110) 这种转换是很危险的，如果把一个范围不在-128~127的int类型的值强制转换为byte，将会得到一个和原值相差很大的数。（10086 -&gt; 102） 在JDK中的使用 来看看之前提到的ByteBuffer中根据两个byte组成一个有符号的short值 1(short)((b1 &lt;&lt; 8) | (b0 &amp; 0xff)); 首先需要了解，Java在对short和int类型的数进行位运算时会把他们转换成int类型的数在进行运算。 将两个byte转换成有符号的short值，理论上只需要把高位和低位拼在一起就好了，假设高位是0xXX，低位是0xYY，那么我们最终想要的值就是0xXXYY。最粗暴的方式： 1(short)( (0xXX &amp; 0xff) &lt;&lt; 8 + (0xYY &amp; 0xff) ) 把得到的值直接强制转换成short(抹去左边16位的0)后就是我们想要的值。 注意到(0xXX &amp; 0xff) &lt;&lt; 8这个表达式和0xXX &lt;&lt; 8这个表达式唯一区别就是得到的数前面16位是0还是f，如果0xXX第一位是0那么两个表达式计算结果一样；如果0xXX第一位是1，那么 ​ (0xXX &amp; 0xff) &lt;&lt; 8 –&gt; 0x0000XX00 0xXX &lt;&lt; 8 –&gt; 0xffffXX00 并不影响后16位的结果，而我们真正关心的只是后16位的值，前16位会在强转时被抹去，所以可以简化成： 1(short)( 0xXX &lt;&lt; 8 + (0xYY &amp; 0xff) ) 第一步0xXX &lt;&lt; 8得到的后25~32位永远是0，第二步0xYY &amp; 0xff得到的17~24永远是0，所以这两个数的加法可以直接用|运算代替，可以转化最终成表达式： 1(short)( 0xXX &lt;&lt; 8 | (0xYY) &amp; 0xff )","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java_class_init","slug":"java_class_init_","date":"2017-03-09T12:52:00.000Z","updated":"2018-06-06T12:32:02.704Z","comments":true,"path":"2017/03/09/java_class_init_/","link":"","permalink":"http://yoursite.com/2017/03/09/java_class_init_/","excerpt":"","text":"Java类加载和个块代码运行时机 Java类从加载到卸载的生命周期 加载(Loading) | 1、获取对应类的二进制字节流 | 2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 ↓ 3、在堆中生成一个代表此类的java.lang.Class对象，作为方法区这些数据的访问入口。验证(Verification) | 1、文件格式验证(0xCAFEBABE，主、次版本号) | 2、元数据验证 | 3、字节码验证 ↓ 4、符号引用验证准备(Preparation) | 为类的静态变量分配内存并将其初始化为默认值(如static a=1,给a分配值0)，这些内存都将 | 在方法区中进行分配。 ↓解析(Resolution) | 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 ↓初始化(Initialization) | 执行类构造器()方法。()方法是由编译器自动收集类中的所有类变量的赋值 | 动作和静态语句块(static{}块)中的语句合并产生的。 ↓使用(Using) ↓卸载(Unloading) 几个例子来深入了解 被重新初始化的变量 1234567891011121314151617181920212223public class TestTest &#123; public static void main(String[] args) throws IOException &#123; StaticVariableInit singleTon = StaticVariableInit.getInstance(); System.out.println(\"count1=\" + singleTon.count1); System.out.println(\"count2=\" + singleTon.count2); &#125;&#125;class StaticVariableInit &#123; private static StaticVariableInit instance = new StaticVariableInit(); public static int count1; public static int count2 = 0; private StaticVariableInit() &#123; count1++; count2++; &#125; public static StaticVariableInit getInstance() &#123; return instance; &#125;&#125; 1、准备阶段，变量count1和count2都被赋值为0 2、初始化阶段开始，因为类构造器是按顺序执行赋值和静态语句块(static{})的，所以先执行new StaticVariableInit()，执行结束后count1和count2都为1 3、instance初始化完成后继续执行类构造器，count1没有赋值操作还是1，count2赋值为0 执行结果 12count1=1count2=0 子类构造函数调用时会先调用父类的构造函数 123456789101112131415161718192021222324252627282930313233343536373839class A &#123; public static int k = 0; static &#123; System.out.println(\"父类静态方法\"); &#125; &#123; System.out.println(\"父类非静态方法\"); &#125; public A() &#123; // 构造 System.out.println(\"父类构造\"); &#125; public A(String obj) &#123; System.out.println(\"父类构造 obj\"); &#125;&#125;class B extends A &#123; static &#123; System.out.println(\"子类静态方法\"); &#125; &#123; System.out.println(\"子类非静态方法\"); &#125; public B() &#123; // 构造 System.out.println(\"子类构造\"); &#125; public B(String obj) &#123; System.out.println(\"子类构造 obj\"); &#125;&#125;public class Demo &#123; public static void main(String args[]) &#123; B b = new B(new String()); &#125;&#125; 子类构造函数如果没有显示调用父类构造函数，那么会先调用父类的空构造。如果父类没有空构造那么必须显示指定要调用的父类构造函数，不然编译不会通过。 执行结果 123456父类静态方法子类静态方法父类非静态方法父类构造子类非静态方法子类构造 obj 123456789101112131415161718192021222324252627282930public class Text &#123; public static int k = 0; public static Text t1 = new Text(\"t1\"); public static Text t2 = new Text(\"t2\"); public static int i = print(\"i\"); public static int n = 99; public int j = print(\"j\"); &#123; print(\"构造块\"); &#125; static &#123; print(\"静态块\"); &#125; public Text(String str) &#123; System.out.println((++k) + \":\" + str + \" i=\" + i + \" n=\" + n); ++i; ++n; &#125; public static int print(String str) &#123; System.out.println((++k) + \":\" + str + \" i=\" + i + \" n=\" + n); ++n; return ++i; &#125; public static void main(String args[]) &#123; Text t = new Text(\"init\"); &#125;&#125; 12345678910111:j i=0 n=02:构造块 i=1 n=13:t1 i=2 n=24:j i=3 n=35:构造块 i=4 n=46:t2 i=5 n=57:i i=6 n=68:静态块 i=7 n=999:j i=8 n=10010:构造块 i=9 n=10111:init i=10 n=102","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"class","slug":"class","permalink":"http://yoursite.com/tags/class/"}]},{"title":"jvm_option_collection","slug":"jvm-option","date":"2017-03-08T13:20:30.000Z","updated":"2018-06-06T12:32:02.704Z","comments":true,"path":"2017/03/08/jvm-option/","link":"","permalink":"http://yoursite.com/2017/03/08/jvm-option/","excerpt":"","text":"JVM参数实用型，会影响运行时环境 堆大小 -Xms 初始堆大小，默认内存的1/64(1GB) -Xmx 最大堆大小，默认物理内存的1/4 (&lt;1GB) -Xmn 年轻带大小 -XX:MinHeapFreeRatio=40 FullGC后如果老年代剩余容量小于40%则扩容,默认是40 -XX:MaxHeapFreeRatio=70 FullGC后如果老年代剩余容量大于70%则缩容,默认是70 -XX:NewSize=5m 年轻带大小，和-Xmn同时存在则以-Xmn为主(hotspot 25.101-b13) -XX:MetaspaceSize 1.8以后的永久带大小初始值 -XX:MaxMetaspaceSize 1.8以后的永久带最大值 -XX:Xss=512k 线程栈大小 配合GC -XX:+DisableEx 屏蔽System.gc() -XX:MaxTenuringThreshold={n} s区晋升最大次数 -XX:CMSInitiatingOccupancyFraction={n} CMS触发百分比 -XX:+UseCMSCompactAtFullCollection //CMS后进行碎片整理 -XX:CMSFullGCsBeforeCompaction={n} //CMS若干次后进行一次碎片 -XX:ParalelCMSThreads //CMS线程数量 -XX:ParalelGCThreads 指定GC线程数量 -XX:MaxGCPauseMills 最大GC停顿时间 -XX:GCTimeRatio 垃圾收集时间占总时间的比 大于3M的对象直接分配到old区,只能在ParNew和Serial使用,Parallel Scavenge不认识此参数 -XX:Pretenuresizethreshold=3145728 每次Minor GC执行完以后，虚拟机会检查之前晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则发起一次Full/Major GC，如果小于，则查看HandlePromotionFailure值是否允许担保失败，如果允许，那只会进行一次Minor GC。如果不允许失败，那么也要改为进行一次Full/Major GC -XX:+HandlePromotionFailure 锁相关 -XX:+DoEscapeAnalysis 开启逃逸分析 -XX:+EliminateLocks 锁消除,基于逃逸分析 内存分配(参考) 在指针碰撞(Bump the Pointer)的内存分配方式中,为了防止每次给新对象分配内存都CAS申请内存,可以打开TLAB一次预先申请一小块内存给指定线程使用 另一种分配方式是空闲列表(Free List) ，空闲列表需要CAS吗？ -XX:+UseTLAB 打开本地线程分配缓冲区(Thread Local Allocation Buffer) 对象中的fields都是按照longs/doubles、ints、short/chars、bytes/booleans、opps(Ordianary Object Points)顺序分配的 -XX:+CompactFields 将一些短类型插入header和long/doubles之间 优化运行时环境 -Xverify:none 关闭字节码验证 关闭方法热度衰减。在指定时间内方法调用次数达不到即时编译器编译的要求，就会把方法调用次数减半 -XX:-UseCounterDecay -XX:CounterHalfLifeTime 通过此参数设置半衰期时间，单位秒 -XX:+PrintCompilation 打印被JIT编译的方法 System.gc()是否参与GC统计,默认为false.JVM会根据统计数据自适应调整GC参数 -XX:-UseAdaptiveSizePolicyWithSystemGC -agentlib:hprof=cpu=times,interval=10 采样统计各个方法占用cpu时长 -XX:-UseGCOverheadLimit 提前预测JVM是否OOM 辅助型，辅助排查 追踪初始化参数 -XX:+PrintCommandLineFlags 打印用户指定的或者JVM根据环境自适应的参数 -XX:+PrintFlagsFinal 初始化完成后打印参数 GC日志 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC 在GC前后打印出Heap信息 -Xloggc:f:\\gc.log 堆日志 -XX:+HeapDumpOnOutOfMemoryError OOM时导出堆到文件 -XX:+HeapDumpPath 堆导出的位置 -XX:+OnOutOfMemoryError OOM时执行一个脚本 verbose -verbose:class 打印出加载的class信息 -verbose:gc 打印出GC信息 -verbose:jni 打印出native方法调用的相关情况 命令查询jinfo -flag MaxTenuringThreshold {pid} 显示晋升阈值是多少，此命令可以查询当前JVM的某个参数 remarks:remark1 参考 remark2 著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。 作者：匿名用户 链接：http://www.zhihu.com/question/21367720/answer/19970887 来源：知乎 挖个坑，如果有人赞，我就把某大型网站的jvm启动参数贴上来。谢赞，填坑。 -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 -Xmn和-Xmx之比大概是1:9，新生代内存太大会导致young gc时间较长，一个好的Web系统应该是每次http请求申请内存都能在young gc回收掉，full gc永不发生。所以xmn的值应该是保证够用（够http并发请求之用）的前提下最小。 remark3 JDK1.7 update14的GC，有连线代表可以搭配使用","categories":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/categories/JVM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"shell_read_and_create_dir","slug":"shell_read_and_create_dir","date":"2017-02-18T10:30:30.000Z","updated":"2018-06-06T12:32:02.705Z","comments":true,"path":"2017/02/18/shell_read_and_create_dir/","link":"","permalink":"http://yoursite.com/2017/02/18/shell_read_and_create_dir/","excerpt":"","text":"Shell遍历和创建目录 需求：现在有一个文件处理脚本，可以将一个文件按一定规则处理并输出。 接收两个参数： $1，文件输出路径 $2，原文件路径现在需要写一个脚本，通过传递一个路径来把该路径下的所有文件都通过这个脚本处理并输出 my_bash.sh 是文件处理脚本名 12345678910111213141516171819202122232425262728293031323334353637383940#!bin/shfunction searchFile() &#123; # 参数是目录路径 out_root=$2 for file in $1 do # 是文件则开始压缩 echo $file if test -f $file then path=$&#123;file:$3&#125; # %/* 从右边开始取第一个/然后把他右边的字符都删掉，因为创建目录不能用文件名去创建 dir=$out_root$&#123;path%/*&#125; mkdir -p $dir my_bash.sh \"$2$path\" \"$file\" fi if test -d $file then # $file不带/，所以加上/ searchFile \"$file/*\" $2 $3 fi done&#125;input_dir=$1output_dir=$2#如果路径最后一个字符是/，删除之if [ $&#123;input_dir:0-1&#125; == '/' ]then input_dir=$&#123;input_dir%/*&#125;fiif [ $&#123;output_dir:0-1&#125; == '/' ]then output_dir=$&#123;output_dir%/*&#125;fi# 输入路径 输出路径 输入路径的长度searchFile $input_dir $output_dir $&#123;#input_dir&#125; 两个参数，\\$1 输入路径 \\$输出路口 主要遇到的问题： 用户输入的参数结尾有可能带/，也有可能不带/，所以在调用处理函数之前先统一格式 遍历文件夹，文件夹名后+*（如/data1/\\）表示该文件夹下所有子文件夹和文件组成的字符串 （空格隔开）*","categories":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/categories/Shell/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}